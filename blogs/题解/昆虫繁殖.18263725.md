
问题分析：
题目中要求的是z个月后的成虫个数，即第z+1个月的成虫个数。我们只需定义一个数组a存储每个月成虫的个数。考虑到每个月会有卵变成新的成虫，所以我们还需定义一个数组b存储每个月的新增卵的数量。

递推公式为 a[i] = a[i-1] + b[i-2]。（第i个月的成虫数量a[i]，等于第(i-1)个月的成虫数量a[i-1]，加上第(i-2)个月的新增卵数量b[i-2]变成的成虫）；
b[i]=a[i-x] * y

解决方案：
```
#include <bits/stdc++.h>
using namespace std;
//用long long，不然出现一个测试点过不了，即程序没毛病，需要考虑边界和范围
long long a[60];//全局变量，不使用栈内存
int main() {
	int x,y,z;
	cin>>x>>y>>z; 
	for(int i=1;i<=x;i++){//过x月产卵，才会有可能出成虫，所以之前都为1
		a[i]=1;
	}
	for(int i=x+1;i<=z+1;i++){
		a[i]=a[i-1]+a[i-x-2]*y;
	}
	cout<<a[z+1];//需要注意z个月后 
}
```
```



---------------------------------------------------------------------------------------------------------
```
## 题目分析
###  题意
找出所有 N 位数中，包含偶数个 3 的数字个数。

### 样例数据分析
### 样例输入 2
表示所有 2 位数，那就是 10 ~ 99，一共有 99-10+1=90 个数字。由于数据比较小，我们可以列出所有含有奇数个 3 的数字，即 13、23、30、31、32、34、35、36、37、38、39、43、53、63、73、83、93，这样合计 17 个数字。因此含有偶数个 3 的数字有 90-17=73 个。注意零也是偶数。

递推思路
当 N=1，数字范围为 0 ~ 9，合计 9-0+1=10 个。

（1）含有偶数个 3 数字有 9 个（0、1、2、4、5、6、7、8、9）。 

（2）含有奇数个 3 数字有 1 个（3）。

当 N=2，数字范围为 10 ~ 99，合计 99-10+1=90 个。

（1）含有偶数个 3 数字的构成：前面一位数中含有奇数个 3 数字，在其前面加上数字 3 的组合，有 1* 1=1个，即数字 3，这样有 1 个数字；前面一位含有偶数个 3 数字（0、1、2、4、5、6、7、8、9），在其前面加上不是 3 的数字（1、2、4、5、6、7、8、9）的组合，有 8*9=72 个。合计 72+1=73。

（2）含有奇数个 3 数字的构成：前面一位数中含有奇数个 3 ，在其前面加上数字为（1、2、4、5、6、7、8、9）的组合，有 8*1=8 个。前面一位数中含有含有偶数个 3 数字（0、1、2、4、5、6、7、8、9），在其前面加上数字为 3 的组合，有 9*1=9 个。合计 8+9=17 个。

当 N=3，数字范围为 100 ~ 999，合计 999-100+1=900 个。

（1）含有偶数个 3 数字的构成：前面两位数字中含有奇数个 3（有 1*9+9*1 个，即18个，注意这个时候数字 0 可以放在前头，因为百位我们还能加数字），在其前面加上数字 3 的组合，合计 18*1=18 个；前面两位数字中含有偶数个 3（有 9*9+1*1 个，即82个，注意这个时候数字 0 可以放在前头，因为百位我们还能加数字） ，数字前加上不是 3 的数字（1、2、4、5、6、7、8、9），有 82*8=656。合计有 18+656=674 个。

（2）含有奇数个 3 数字的构成：前面两位数字中含有奇数个 3（有 1*9+9*1 个，即18个，注意这个时候数字 0 可以放在前头，因为百位我们还能加数字），在其前面加上不是 3 的数字（1、2、4、5、6、7、8、9）的组合，合计 18*8=144 个；前面两位数字中含有偶数个 3（有 9*9+1*1 个，即82个，注意这个时候数字 0 可以放在前头，因为百位我们还能加数字） ，数字前加上数字 3，有 82*1=82。合计有 144+82=226 个。

以此类推。这样我们就可以推倒出如下的递推公式：

N 表示位数，a[i] 表示到第 i 位包含偶数个 3 的数字数量，b[i] 表示到第 i 位包含奇数个 3 的数字数量
```
a[1] = 9                              b[1] = 1
当 i<N 的时候
a[i] = a[i-1]*9 + b[i-1]*1            b[i] = a[i-1]*1 + b[i-1]*9
当 i==N 的时候，由于首位不能为零
a[i] = a[i-1]*8 + b[i-1]*1            b[i] = a[i-1]*1 + b[i-1]*8
```
---
```cpp
#include <bits/stdc++.h>
using namespace std;
int m, n;
char a[105][105];
int cnt=0;
int main() {
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            cin >> a[i][j];
        }
    }
    cin >> m;
    for(int i = 2; i <= m; i++) {//递推从第二天到第m天
        for(int j = 1; j <= n; j++) {
            for(int k = 1; k <= n; k++) {
                if (a[j][k] == '.') {//如果住人
                    //如果隔壁有病人
                    if (a[j - 1][k] == '@' || a[j + 1][k] == '@'
                    || a[j][k - 1] == '@' || a[j][k + 1] == '@') {
                        a[j][k]='*';//被感染
                    }
                }
            }
        }
        for(int j = 1; j <= n; j++) {//被感染的人发病
            for(int k = 1; k <= n; k++) {
                if (a[j][k] == '*') {
                        a[j][k]='@';//变成病人
                }
            }
        }
    }
    for(int i = 1; i <= n; i++) {//循环统计病人个数
        for(int j = 1; j <= n; j++) {
            if ( a[i][j]=='@'){
                cnt++;
            }
        }
    }
    cout<<cnt;
    return 0;
}
```
