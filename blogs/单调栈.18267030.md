                                              单调栈学习记录
   模板代码：\
   STL版
   ```cpp
    stack <int> st;
    for(int i=1;i<=n;++i)
    {
        int w=re();
        while (!st.empty()&&w<=st.top())
            st.pop();
        st.push(w);
    }
   ```
   手写stack版:
   ```cpp
    int top=0;
    for(int i=1;i<=n;++i)
    {
        int w=re();
        while (top>0&&w<=st[top])
            top--;
        st[++top]=w;
    }
   ```
单调栈在求“以某个值为最值的最大区间”有着时间复杂度$O(n)$的出色表现
例题：
# [USACO06NOV] Bad Hair Day S

## 题目描述

农夫约翰有 $N$ 头奶牛正在过乱头发节。

每一头牛都站在同一排面朝右，它们被从左到右依次编号为 $1, 2, \cdots, N$。编号为 $i$ 的牛身高为 $h_i$。第 $N$ 头牛在最前面，而第 $1$ 头牛在最后面。

对于第 $i$ 头牛**前面**的第 $j$ 头牛，如果 $h_i>h_{i+1}, h_i>h_{i+2}, \cdots, h_i>h_j$，那么认为第 $i$ 头牛可以看到第 $i+1$ 到第 $j$ 头牛。

定义 $C_i$ 为第 $i$ 头牛所能看到的牛的数量。请帮助农夫约翰求出 $C _ 1 + C _ 2 + \cdots + C _ N$。

## 输入格式

输入共 $N + 1$ 行。

第一行为一个整数 $N$，代表牛的个数。  
接下来 $N$ 行，每行一个整数 $a _ i$，分别代表第 $1, 2, \cdots, N$ 头牛的身高。

## 输出格式

输出共一行一个整数，代表 $C _ 1 + C _ 2 + \cdots + C _ N$。

## 样例 #1

### 样例输入 #1

```
6
10
3
7
4
12
2
```

### 样例输出 #1

```
5
```

## 提示

### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq N \leq 8 \times 10 ^ 4$，$1 \leq h _ i \leq 10 ^ 9$。
## 分析
注意到，一头牛能看到的牛的数量的总和，与一头牛能被几头牛看到的总和是一样的，与其求一头牛能看到的牛的数量不如求一头牛能被几头牛看到，我们维护一个栈，如果即将入栈的元素大于栈顶的元素那么就将栈顶的元素$pop()$掉直到不大于为止，然后入栈，一直保持单调，每次累加 $size()$,最后输出